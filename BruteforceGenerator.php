<?php

/**
 * Class BruteforceGenerator
 *
 * @description A memory efficient data generator for bruteforcing.
 * @author Samed Düzçay <samedduzcay@gmail.com>
 * @license GNU GENERAL PUBLIC LICENSE. Version 3, 29 June 2007. Look at the LICENSE file for further information.
 * @version 1.0
 *
 */
class BruteforceGenerator
{
    /**
     * @var int Minimum length
     */
    private $minLength;
    /**
     * @var int Maximum length
     */
    private $maxLength;
    /**
     * @var array
     */
    private $chars;
    /**
     * @var string Data after generated by getNewData() is accessible by this variable.
     */
    public $newData;
    /**
     * @var
     */
    private static $pointers;
    /**
     * @var int
     */
    private $tempPointer;
    /**
     * @var bool True when job is done
     */
    public $jobDone = false;

    /**
     * @return int Minimum data length
     */
    public function getMinLength()
    {
        return $this->minLength;
    }

    /**
     * @param int $minLength
     */
    public function setMinLength($minLength)
    {
        $this->minLength = $minLength;
    }

    /**
     * @return int Maximum data length
     */
    public function getMaxLength()
    {
        return $this->maxLength;
    }

    /**
     * @param int $maxLength
     */
    public function setMaxLength($maxLength)
    {
        $this->maxLength = $maxLength;
    }

    /**
     * @return array Chars to build bruteforce data
     */
    public function getChars()
    {
        return $this->chars;
    }

    /**
     * Sets your own characters for generating bruteforce data
     * Default characters are = a-z A-Z 0-9 _ -
     * @param array $chars Set characters used for building data, default is a-zA-Z0-9-_
     */
    public function setChars($chars)
    {
        $this->chars = (array)$chars;
    }

    /**
     * @param int $minLength Minimum path length
     * @param int $maxLength Maximum path length
     */
    public function __construct($minLength, $maxLength)
    {
        $this->minLength = $minLength;
        $this->maxLength = $maxLength;
        $this->tempPointer = $this->minLength - 1;
        static::$pointers = array_fill(0, $this->minLength, 0);
        $this->chars = array_merge(range('a', 'z'), range('A', 'Z'), range('0', '9'), array('_', '-'));
    }


    /**
     * This method generates a new data everytime it's called.
     * @return bool|string New data or false when job is done.
     */
    public function getNewData()
    {

        if ($this->tempPointer >= 0) {
            $this->newData = "";
            if (static::$pointers[$this->tempPointer] == count($this->chars) - 1) { // If the last char is z
                if (!(array_key_exists($this->tempPointer - 1, static::$pointers) && static::$pointers[$this->tempPointer - 1] == count($this->chars) - 1)) {
                    for ($i = 0; $i < $this->minLength; $i++) {
                        $this->newData .= $this->chars[static::$pointers[$i]];
                    }
                }
                static::$pointers[$this->tempPointer] = 0;
                $this->tempPointer--;
            } elseif ($this->tempPointer == $this->minLength - 1) {
                for ($j = 0; $j < $this->minLength; $j++) {
                    $this->newData .= $this->chars[static::$pointers[$j]];
                }
                static::$pointers[$this->tempPointer]++;
            } else {
                static::$pointers[$this->tempPointer]++;
                $this->tempPointer > 0 ? $this->tempPointer++ : $this->tempPointer = $this->minLength - 1;
            }
            if ($this->newData !== "")
                return $this->newData;
            else
                return $this->getNewData();

            /*
            * Approach to maxLength if current one is finished.
            */
        } elseif ($this->minLength < $this->maxLength) {

            static::$pointers = array_fill(0, ++$this->minLength, 0);
            $this->tempPointer = $this->minLength - 1;
            return $this->getNewData();

            /**
             * Job is done.
             */
        } else {
            $this->jobDone = true;
            return false;
        }

    }

}